#include "cube/cube_model.hpp"
#include "cube/cube_normals.hpp"
#include "cube/cube_uv.hpp"
#include "cube/cube_texture.hpp"
#include "cube/cubespec_texture.hpp"

#include "monitor/monitor_model.hpp"
#include "monitor/monitor_normals.hpp"
#include "monitor/monitor_uv.hpp"

#include "plane/plane_model.hpp"
#include "plane/plane_normals.hpp"
#include "plane/plane_uv.hpp"

const char* vertexShaderCode =
                    "#version 400\n"
                    "layout (location = 0) in vec3 positions;" 
                    "layout (location = 1) in vec3 normals;" 
                    "layout (location = 2) in vec2 uv;" 
                    "uniform mat4 proj;" 
                    "uniform mat4 translate;" 
                    "uniform mat4 xrot;" 
                    "uniform mat4 yrot;" 
                    "uniform mat4 meshm;" 
                    "uniform mat4 meshx;" 
                    "uniform mat4 meshy;" 
                    "uniform mat4 meshz;" 
                    "uniform mat4 meshs;" 

                    "uniform mat4 sproj[10];" 
                    "uniform mat4 stranslate[10];" 
                    "uniform mat4 sxrot[10];" 
                    "uniform mat4 syrot[10];" 

                    "out vec2 fuv;"
                    "out vec3 fnormals;"
                    "out vec3 fpos;"
                    "out vec4 projlightmat;"
                    "out vec4 projlightmat2;"
                    "out vec4 projlightmat3;"
                    "out vec4 projlightmat4;"
                    "out vec4 projlightmat5;"
                    "out vec4 projlightmat6;"
                    "out vec4 projlightmat7;"
                    "out vec4 projlightmat8;"
                    "out vec4 projlightmat9;"
                    "out vec4 projlightmat10;"
                    "void main() {" 
                    "  vec4 tr = meshs * vec4(positions, 1.0f);" 
                    "  tr = meshm * meshx * meshy * meshz * tr;" 
                    "  gl_Position = proj * xrot * yrot * translate * tr;" 
                            "fuv = uv;"
                            "fnormals = normals;"
                            "fpos = vec3(mat4(1.0f) * vec4(positions, 1.0f));"
                            "projlightmat = sproj[0] * sxrot[0] * syrot[0] * stranslate[0] * tr;"
                            "projlightmat2 = sproj[1] * sxrot[1] * syrot[1] * stranslate[1] * tr;"
                            "projlightmat3 = sproj[2] * sxrot[2] * syrot[2] * stranslate[2] * tr;"
                            "projlightmat4 = sproj[3] * sxrot[3] * syrot[3] * stranslate[3] * tr;"
                            "projlightmat5 = sproj[4] * sxrot[4] * syrot[4] * stranslate[4] * tr;"
                            "projlightmat6 = sproj[5] * sxrot[5] * syrot[5] * stranslate[5] * tr;"
                            "projlightmat7 = sproj[6] * sxrot[6] * syrot[6] * stranslate[6] * tr;"
                            "projlightmat8 = sproj[7] * sxrot[7] * syrot[7] * stranslate[7] * tr;"
                            "projlightmat9 = sproj[8] * sxrot[8] * syrot[8] * stranslate[8] * tr;"
                            "projlightmat10 = sproj[9] * sxrot[9] * syrot[9] * stranslate[9] * tr;"
                    "}";

const char* fragmentShaderCode =
                    "#version 400\n" 
                    "uniform sampler2D tex1;"
                    "uniform sampler2D spec1;"
                    "uniform sampler2D shadowMap0;"
                    "uniform sampler2D shadowMap1;"
                    "uniform sampler2D shadowMap2;"
                    "uniform sampler2D shadowMap3;"
                    "uniform sampler2D shadowMap4;"
                    "uniform sampler2D shadowMap5;"
                    "uniform sampler2D shadowMap6;"
                    "uniform sampler2D shadowMap7;"
                    "uniform sampler2D shadowMap8;"
                    "uniform sampler2D shadowMap9;"
                    "uniform vec3 lightsPos[10];"
                    "uniform vec3 lightsCol[10];"
                    "uniform int lightStates[10];"
                    "uniform vec3 viewPos;"
                    "in vec4 projlightmat;"
                    "in vec4 projlightmat2;"
                    "in vec4 projlightmat3;"
                    "in vec4 projlightmat4;"
                    "in vec4 projlightmat5;"
                    "in vec4 projlightmat6;"
                    "in vec4 projlightmat7;"
                    "in vec4 projlightmat8;"
                    "in vec4 projlightmat9;"
                    "in vec4 projlightmat10;"
                    "in vec2 fuv;"
                    "in vec3 fnormals;"
                    "in vec3 fpos;"
                    "layout(location = 0) out vec4 color;"
                    "float shadowMapping(){" 
                    "  vec3 projected = projlightmat.xyz / projlightmat.w;" 
                    "  float shadow = 0.0f;" 
                    "  if(projected.z <= 1.0f){" 
                    "   projected = (projected + 1.0f)/2.0f;" 
                    "   float closestDepth = texture(shadowMap0, projected.xy).r;" 
                    "   float currentDepth = projected.z;" 
                    "   if(currentDepth - 0.00005 > closestDepth){" 
                    "       shadow+=1.0f;" 
                    "   }" 
                    "  }" 
                    "  return shadow;" 
                    "}" 
                    "float shadowMapping2(){" 
                    "  vec3 projected = projlightmat2.xyz / projlightmat2.w;" 
                    "  float shadow = 0.0f;" 
                    "  if(projected.z <= 1.0f){" 
                    "   projected = (projected + 1.0f)/2.0f;" 
                    "   float closestDepth = texture(shadowMap1, projected.xy).r;" 
                    "   float currentDepth = projected.z;" 
                    "   if(currentDepth - 0.00005 > closestDepth){" 
                    "       shadow+=1.0f;" 
                    "   }" 
                    "  }" 
                    "  return shadow;" 
                    "}" 
                    "float shadowMapping3(){" 
                    "  vec3 projected = projlightmat3.xyz / projlightmat3.w;" 
                    "  float shadow = 0.0f;" 
                    "  if(projected.z <= 1.0f){" 
                    "   projected = (projected + 1.0f)/2.0f;" 
                    "   float closestDepth = texture(shadowMap2, projected.xy).r;" 
                    "   float currentDepth = projected.z;" 
                    "   if(currentDepth - 0.00005 > closestDepth){" 
                    "       shadow+=1.0f;" 
                    "   }" 
                    "  }" 
                    "  return shadow;" 
                    "}" 
                    "float shadowMapping4(){" 
                    "  vec3 projected = projlightmat4.xyz / projlightmat4.w;" 
                    "  float shadow = 0.0f;" 
                    "  if(projected.z <= 1.0f){" 
                    "   projected = (projected + 1.0f)/2.0f;" 
                    "   float closestDepth = texture(shadowMap3, projected.xy).r;" 
                    "   float currentDepth = projected.z;" 
                    "   if(currentDepth - 0.00005 > closestDepth){" 
                    "       shadow+=1.0f;" 
                    "   }" 
                    "  }" 
                    "  return shadow;" 
                    "}" 
                    "float shadowMapping5(){" 
                    "  vec3 projected = projlightmat5.xyz / projlightmat5.w;" 
                    "  float shadow = 0.0f;" 
                    "  if(projected.z <= 1.0f){" 
                    "   projected = (projected + 1.0f)/2.0f;" 
                    "   float closestDepth = texture(shadowMap4, projected.xy).r;" 
                    "   float currentDepth = projected.z;" 
                    "   if(currentDepth - 0.00005 > closestDepth){" 
                    "       shadow+=1.0f;" 
                    "   }" 
                    "  }" 
                    "  return shadow;" 
                    "}" 
                    "float shadowMapping6(){" 
                    "  vec3 projected = projlightmat6.xyz / projlightmat6.w;" 
                    "  float shadow = 0.0f;" 
                    "  if(projected.z <= 1.0f){" 
                    "   projected = (projected + 1.0f)/2.0f;" 
                    "   float closestDepth = texture(shadowMap5, projected.xy).r;" 
                    "   float currentDepth = projected.z;" 
                    "   if(currentDepth - 0.00005 > closestDepth){" 
                    "       shadow+=1.0f;" 
                    "   }" 
                    "  }" 
                    "  return shadow;" 
                    "}" 
                    "float shadowMapping7(){" 
                    "  vec3 projected = projlightmat7.xyz / projlightmat7.w;" 
                    "  float shadow = 0.0f;" 
                    "  if(projected.z <= 1.0f){" 
                    "   projected = (projected + 1.0f)/2.0f;" 
                    "   float closestDepth = texture(shadowMap6, projected.xy).r;" 
                    "   float currentDepth = projected.z;" 
                    "   if(currentDepth - 0.00005 > closestDepth){" 
                    "       shadow+=1.0f;" 
                    "   }" 
                    "  }" 
                    "  return shadow;" 
                    "}" 
                    "float shadowMapping8(){" 
                    "  vec3 projected = projlightmat8.xyz / projlightmat8.w;" 
                    "  float shadow = 0.0f;" 
                    "  if(projected.z <= 1.0f){" 
                    "   projected = (projected + 1.0f)/2.0f;" 
                    "   float closestDepth = texture(shadowMap7, projected.xy).r;" 
                    "   float currentDepth = projected.z;" 
                    "   if(currentDepth - 0.00005 > closestDepth){" 
                    "       shadow+=1.0f;" 
                    "   }" 
                    "  }" 
                    "  return shadow;" 
                    "}" 
                    "float shadowMapping9(){" 
                    "  vec3 projected = projlightmat9.xyz / projlightmat9.w;" 
                    "  float shadow = 0.0f;" 
                    "  if(projected.z <= 1.0f){" 
                    "   projected = (projected + 1.0f)/2.0f;" 
                    "   float closestDepth = texture(shadowMap8, projected.xy).r;" 
                    "   float currentDepth = projected.z;" 
                    "   if(currentDepth - 0.00005 > closestDepth){" 
                    "       shadow+=1.0f;" 
                    "   }" 
                    "  }" 
                    "  return shadow;" 
                    "}" 
                    "float shadowMapping10(){" 
                    "  vec3 projected = projlightmat10.xyz / projlightmat10.w;" 
                    "  float shadow = 0.0f;" 
                    "  if(projected.z <= 1.0f){" 
                    "   projected = (projected + 1.0f)/2.0f;" 
                    "   float closestDepth = texture(shadowMap9, projected.xy).r;" 
                    "   float currentDepth = projected.z;" 
                    "   if(currentDepth - 0.00005 > closestDepth){" 
                    "       shadow+=1.0f;" 
                    "   }" 
                    "  }" 
                    "  return shadow;" 
                    "}" 
                    "float phongl(vec3 lightpos){" 
                    "  float ambient = 0.1;" 
                    "  vec3 norm = normalize(fnormals);" 
                    "  vec3 ldir = normalize(lightpos-fpos);" 
                    "  float diffuse = max(dot(norm, ldir), 0.0);" 
                    "  vec3 viewDir = normalize(-viewPos - fpos);" 
                    "  vec3 halfwayDir = normalize(ldir + viewDir);" 
                    "  float spec = pow(max(dot(norm, halfwayDir), 0.0), 16.0) * texture(spec1, fuv).r;" 
                    "  float shad = max(shadowMapping()+shadowMapping2()+shadowMapping3()+shadowMapping4()+shadowMapping5()+shadowMapping6()+shadowMapping7()+shadowMapping8()+shadowMapping9()+shadowMapping10(), 0.0);" 
                    "  return float((spec + diffuse)*(1.0-shad)) + ambient;" 
                    "}" 
                    "void main() {" 
                    "  vec3 toOut = phongl(lightsPos[0]) * lightsCol[0] * texture(tex1, fuv).rgb;" 
                    "  toOut += phongl(lightsPos[1]) * lightsCol[1] * texture(tex1, fuv).rgb;"
                    "  toOut += phongl(lightsPos[2]) * lightsCol[2] * texture(tex1, fuv).rgb;"
                    "  toOut += phongl(lightsPos[3]) * lightsCol[3] * texture(tex1, fuv).rgb;"
                    "  toOut += phongl(lightsPos[4]) * lightsCol[4] * texture(tex1, fuv).rgb;"
                    "  toOut += phongl(lightsPos[5]) * lightsCol[5] * texture(tex1, fuv).rgb;" 
                    "  toOut += phongl(lightsPos[6]) * lightsCol[6] * texture(tex1, fuv).rgb;"
                    "  toOut += phongl(lightsPos[7]) * lightsCol[7] * texture(tex1, fuv).rgb;"
                    "  toOut += phongl(lightsPos[8]) * lightsCol[8] * texture(tex1, fuv).rgb;"
                    "  toOut += phongl(lightsPos[9]) * lightsCol[9] * texture(tex1, fuv).rgb;"
                    "  color = vec4( toOut, 1.0);" 
                    "}";

const char* fragmentShaderCode2 =
            "#version 400\n" 
                    "precision mediump float;" 
                    "uniform sampler2D tex1;"
                    "uniform sampler2D spec1;"
                    "uniform sampler2D shadowMap0;"
                    "uniform vec3 lightsPos[10];"
                    "in vec4 projlightmat;"
                    "in vec2 fuv;"
                    "in vec3 fnormals;"
                    "layout(location = 0) out vec4 color;"
                    "void main() {" 
                    "  color = vec4(texture(shadowMap0, fuv).rrr, 1.0);" 
                    "}";

const char* vertexuiShaderCode =
                    "#version 400\n"
                    "layout (location = 0) in vec3 positions;" 
                    "layout (location = 1) in vec3 normals;" 
                    "layout (location = 2) in vec2 uv;" 
                    "uniform mat4 proj;" 
                    "uniform vec2 res;" 
                    "uniform mat4 translate;" 
                    "uniform mat4 xrot;" 
                    "uniform mat4 yrot;" 
                    "uniform mat4 meshm;" 
                    "uniform mat4 meshs;"  

                    "out vec2 fuv;"
                    "out vec3 fnormals;"
                    "out vec3 fpos;"
                    "out vec4 projlightmat;"
                    "void main() {" 
                    "  vec4 tr = meshs * vec4(positions.xy/res.xy, 0, 1.0f);" 
                    "  gl_Position = meshm * tr;" 
                            "fuv = vec2(uv.x, uv.y);"
                    "}";

const char* fragmentuiShaderCode =
                    "#version 400\n" 
                    "uniform sampler2D tex1;"
                    "uniform sampler2D spec1;"
                    "uniform sampler2D shadowMap0;"
                    "uniform vec3 lightsPos[10];"
                    "uniform vec3 lightsCol[10];"
                    "uniform int lightStates[10];"
                    "uniform vec3 viewPos;"
                    "in vec4 projlightmat;"
                    "in vec2 fuv;"
                    "in vec3 fnormals;"
                    "in vec3 fpos;"
                    "layout(location = 0) out vec4 color;"
                    "void main(){"
                    "  color = vec4( texture(tex1, fuv).rgb, 1.0);" 
                    "}";

const char* vertexShaderCode32 =
                    "#version 320 es\n"
                    "in vec3 positions;" 
                    "in vec3 normals;" 
                    "in vec2 uv;" 
                    "uniform mat4 proj;" 
                    "uniform mat4 translate;" 
                    "uniform mat4 xrot;" 
                    "uniform mat4 yrot;" 
                    "uniform mat4 meshm;" 
                    "uniform mat4 meshx;" 
                    "uniform mat4 meshy;" 
                    "uniform mat4 meshz;" 
                    "uniform mat4 meshs;" 

                    "uniform mat4 sproj[10];" 
                    "uniform mat4 stranslate[10];" 
                    "uniform mat4 sxrot[10];" 
                    "uniform mat4 syrot[10];" 

                    "out vec2 fuv;"
                    "out vec3 fnormals;"
                    "out vec3 fpos;"
                    "out vec4 projlightmat;"
                    "out vec4 projlightmat2;"
                    "out vec4 projlightmat3;"
                    "out vec4 projlightmat4;"
                    "out vec4 projlightmat5;"
                    "out vec4 projlightmat6;"
                    "out vec4 projlightmat7;"
                    "out vec4 projlightmat8;"
                    "out vec4 projlightmat9;"
                    "out vec4 projlightmat10;"
                    "void main() {" 
                    "  vec4 tr = meshs * vec4(positions, 1.0f);" 
                    "  tr = meshm * meshx * meshy * meshz * tr;" 
                    "  gl_Position = proj * xrot * yrot * translate * tr;" 
                            "fuv = uv;"
                            "fnormals = normals;"
                            "fpos = vec3(mat4(1.0f) * vec4(positions, 1.0f));"
                            "projlightmat = sproj[0] * sxrot[0] * syrot[0] * stranslate[0] * tr;"
                            "projlightmat2 = sproj[1] * sxrot[1] * syrot[1] * stranslate[1] * tr;"
                            "projlightmat3 = sproj[2] * sxrot[2] * syrot[2] * stranslate[2] * tr;"
                            "projlightmat4 = sproj[3] * sxrot[3] * syrot[3] * stranslate[3] * tr;"
                            "projlightmat5 = sproj[4] * sxrot[4] * syrot[4] * stranslate[4] * tr;"
                            "projlightmat6 = sproj[5] * sxrot[5] * syrot[5] * stranslate[5] * tr;"
                            "projlightmat7 = sproj[6] * sxrot[6] * syrot[6] * stranslate[6] * tr;"
                            "projlightmat8 = sproj[7] * sxrot[7] * syrot[7] * stranslate[7] * tr;"
                            "projlightmat9 = sproj[8] * sxrot[8] * syrot[8] * stranslate[8] * tr;"
                            "projlightmat10 = sproj[9] * sxrot[9] * syrot[9] * stranslate[9] * tr;"
                    "}";

const char* fragmentShaderCode32 =
                    "#version 320 es\n" 
                    "uniform sampler2D tex1;"
                    "uniform sampler2D spec1;"
                    "uniform sampler2D shadowMap0;"
                    "uniform sampler2D shadowMap1;"
                    "uniform sampler2D shadowMap2;"
                    "uniform sampler2D shadowMap3;"
                    "uniform sampler2D shadowMap4;"
                    "uniform sampler2D shadowMap5;"
                    "uniform sampler2D shadowMap6;"
                    "uniform sampler2D shadowMap7;"
                    "uniform sampler2D shadowMap8;"
                    "uniform sampler2D shadowMap9;"
                    "uniform vec3 lightsPos[10];"
                    "uniform vec3 lightsCol[10];"
                    "uniform int lightStates[10];"
                    "uniform vec3 viewPos;"
                    "in vec4 projlightmat;"
                    "in vec4 projlightmat2;"
                    "in vec4 projlightmat3;"
                    "in vec4 projlightmat4;"
                    "in vec4 projlightmat5;"
                    "in vec4 projlightmat6;"
                    "in vec4 projlightmat7;"
                    "in vec4 projlightmat8;"
                    "in vec4 projlightmat9;"
                    "in vec4 projlightmat10;"
                    "in vec2 fuv;"
                    "in vec3 fnormals;"
                    "in vec3 fpos;"
                    "layout(location = 0) out vec4 color;"
                    "float shadowMapping(){" 
                    "  vec3 projected = projlightmat.xyz / projlightmat.w;" 
                    "  float shadow = 0.0f;" 
                    "  if(projected.z <= 1.0f){" 
                    "   projected = (projected + 1.0f)/2.0f;" 
                    "   float closestDepth = texture(shadowMap0, projected.xy).r;" 
                    "   float currentDepth = projected.z;" 
                    "   if(currentDepth - 0.00005 > closestDepth){" 
                    "       shadow+=1.0f;" 
                    "   }" 
                    "  }" 
                    "  return shadow;" 
                    "}" 
                    "float shadowMapping2(){" 
                    "  vec3 projected = projlightmat2.xyz / projlightmat2.w;" 
                    "  float shadow = 0.0f;" 
                    "  if(projected.z <= 1.0f){" 
                    "   projected = (projected + 1.0f)/2.0f;" 
                    "   float closestDepth = texture(shadowMap1, projected.xy).r;" 
                    "   float currentDepth = projected.z;" 
                    "   if(currentDepth - 0.00005 > closestDepth){" 
                    "       shadow+=1.0f;" 
                    "   }" 
                    "  }" 
                    "  return shadow;" 
                    "}" 
                    "float shadowMapping3(){" 
                    "  vec3 projected = projlightmat3.xyz / projlightmat3.w;" 
                    "  float shadow = 0.0f;" 
                    "  if(projected.z <= 1.0f){" 
                    "   projected = (projected + 1.0f)/2.0f;" 
                    "   float closestDepth = texture(shadowMap2, projected.xy).r;" 
                    "   float currentDepth = projected.z;" 
                    "   if(currentDepth - 0.00005 > closestDepth){" 
                    "       shadow+=1.0f;" 
                    "   }" 
                    "  }" 
                    "  return shadow;" 
                    "}" 
                    "float shadowMapping4(){" 
                    "  vec3 projected = projlightmat4.xyz / projlightmat4.w;" 
                    "  float shadow = 0.0f;" 
                    "  if(projected.z <= 1.0f){" 
                    "   projected = (projected + 1.0f)/2.0f;" 
                    "   float closestDepth = texture(shadowMap3, projected.xy).r;" 
                    "   float currentDepth = projected.z;" 
                    "   if(currentDepth - 0.00005 > closestDepth){" 
                    "       shadow+=1.0f;" 
                    "   }" 
                    "  }" 
                    "  return shadow;" 
                    "}" 
                    "float shadowMapping5(){" 
                    "  vec3 projected = projlightmat5.xyz / projlightmat5.w;" 
                    "  float shadow = 0.0f;" 
                    "  if(projected.z <= 1.0f){" 
                    "   projected = (projected + 1.0f)/2.0f;" 
                    "   float closestDepth = texture(shadowMap4, projected.xy).r;" 
                    "   float currentDepth = projected.z;" 
                    "   if(currentDepth - 0.00005 > closestDepth){" 
                    "       shadow+=1.0f;" 
                    "   }" 
                    "  }" 
                    "  return shadow;" 
                    "}" 
                    "float shadowMapping6(){" 
                    "  vec3 projected = projlightmat6.xyz / projlightmat6.w;" 
                    "  float shadow = 0.0f;" 
                    "  if(projected.z <= 1.0f){" 
                    "   projected = (projected + 1.0f)/2.0f;" 
                    "   float closestDepth = texture(shadowMap5, projected.xy).r;" 
                    "   float currentDepth = projected.z;" 
                    "   if(currentDepth - 0.00005 > closestDepth){" 
                    "       shadow+=1.0f;" 
                    "   }" 
                    "  }" 
                    "  return shadow;" 
                    "}" 
                    "float shadowMapping7(){" 
                    "  vec3 projected = projlightmat7.xyz / projlightmat7.w;" 
                    "  float shadow = 0.0f;" 
                    "  if(projected.z <= 1.0f){" 
                    "   projected = (projected + 1.0f)/2.0f;" 
                    "   float closestDepth = texture(shadowMap6, projected.xy).r;" 
                    "   float currentDepth = projected.z;" 
                    "   if(currentDepth - 0.00005 > closestDepth){" 
                    "       shadow+=1.0f;" 
                    "   }" 
                    "  }" 
                    "  return shadow;" 
                    "}" 
                    "float shadowMapping8(){" 
                    "  vec3 projected = projlightmat8.xyz / projlightmat8.w;" 
                    "  float shadow = 0.0f;" 
                    "  if(projected.z <= 1.0f){" 
                    "   projected = (projected + 1.0f)/2.0f;" 
                    "   float closestDepth = texture(shadowMap7, projected.xy).r;" 
                    "   float currentDepth = projected.z;" 
                    "   if(currentDepth - 0.00005 > closestDepth){" 
                    "       shadow+=1.0f;" 
                    "   }" 
                    "  }" 
                    "  return shadow;" 
                    "}" 
                    "float shadowMapping9(){" 
                    "  vec3 projected = projlightmat9.xyz / projlightmat9.w;" 
                    "  float shadow = 0.0f;" 
                    "  if(projected.z <= 1.0f){" 
                    "   projected = (projected + 1.0f)/2.0f;" 
                    "   float closestDepth = texture(shadowMap8, projected.xy).r;" 
                    "   float currentDepth = projected.z;" 
                    "   if(currentDepth - 0.00005 > closestDepth){" 
                    "       shadow+=1.0f;" 
                    "   }" 
                    "  }" 
                    "  return shadow;" 
                    "}" 
                    "float shadowMapping10(){" 
                    "  vec3 projected = projlightmat10.xyz / projlightmat10.w;" 
                    "  float shadow = 0.0f;" 
                    "  if(projected.z <= 1.0f){" 
                    "   projected = (projected + 1.0f)/2.0f;" 
                    "   float closestDepth = texture(shadowMap9, projected.xy).r;" 
                    "   float currentDepth = projected.z;" 
                    "   if(currentDepth - 0.00005 > closestDepth){" 
                    "       shadow+=1.0f;" 
                    "   }" 
                    "  }" 
                    "  return shadow;" 
                    "}" 
                    "float phongl(vec3 lightpos){" 
                    "  float ambient = 0.1;" 
                    "  vec3 norm = normalize(fnormals);" 
                    "  vec3 ldir = normalize(lightpos-fpos);" 
                    "  float diffuse = max(dot(norm, ldir), 0.0);" 
                    "  vec3 viewDir = normalize(-viewPos - fpos);" 
                    "  vec3 halfwayDir = normalize(ldir + viewDir);" 
                    "  float spec = pow(max(dot(norm, halfwayDir), 0.0), 16.0) * texture(spec1, fuv).r;" 
                    "  float shad = max(shadowMapping()+shadowMapping2()+shadowMapping3()+shadowMapping4()+shadowMapping5()+shadowMapping6()+shadowMapping7()+shadowMapping8()+shadowMapping9()+shadowMapping10(), 0.0);" 
                    "  return float((spec + diffuse)*(1.0-shad)) + ambient;" 
                    "}" 
                    "void main() {" 
                    "  vec3 toOut = phongl(lightsPos[0]) * lightsCol[0] * texture(tex1, fuv).rgb;" 
                    "  toOut += phongl(lightsPos[1]) * lightsCol[1] * texture(tex1, fuv).rgb;"
                    "  toOut += phongl(lightsPos[2]) * lightsCol[2] * texture(tex1, fuv).rgb;"
                    "  toOut += phongl(lightsPos[3]) * lightsCol[3] * texture(tex1, fuv).rgb;"
                    "  toOut += phongl(lightsPos[4]) * lightsCol[4] * texture(tex1, fuv).rgb;"
                    "  toOut += phongl(lightsPos[5]) * lightsCol[5] * texture(tex1, fuv).rgb;" 
                    "  toOut += phongl(lightsPos[6]) * lightsCol[6] * texture(tex1, fuv).rgb;"
                    "  toOut += phongl(lightsPos[7]) * lightsCol[7] * texture(tex1, fuv).rgb;"
                    "  toOut += phongl(lightsPos[8]) * lightsCol[8] * texture(tex1, fuv).rgb;"
                    "  toOut += phongl(lightsPos[9]) * lightsCol[9] * texture(tex1, fuv).rgb;"
                    "  color = vec4( toOut, 1.0);" 
                    "}";

const char* vertexuiShaderCode32 =
                    "#version 320 es\n"
                    "in vec3 positions;" 
                    "in vec3 normals;" 
                    "in vec2 uv;" 
                    "uniform mat4 proj;" 
                    "uniform vec2 res;" 
                    "uniform mat4 translate;" 
                    "uniform mat4 xrot;" 
                    "uniform mat4 yrot;" 
                    "uniform mat4 meshm;" 
                    "uniform mat4 meshs;"  

                    "out vec2 fuv;"
                    "out vec3 fnormals;"
                    "out vec3 fpos;"
                    "out vec4 projlightmat;"
                    "void main() {" 
                    "  vec4 tr = meshs * vec4(positions.xy/res.xy, 0, 1.0f);" 
                    "  gl_Position = meshm * tr;" 
                            "fuv = vec2(uv.x, uv.y);"
                    "}";

const char* fragmentuiShaderCode32 =
                    "#version 320\n" 
                    "uniform sampler2D tex1;"
                    "uniform sampler2D spec1;"
                    "uniform sampler2D shadowMap0;"
                    "uniform vec3 lightsPos[10];"
                    "uniform vec3 lightsCol[10];"
                    "uniform int lightStates[10];"
                    "uniform vec3 viewPos;"
                    "in vec4 projlightmat;"
                    "in vec2 fuv;"
                    "in vec3 fnormals;"
                    "in vec3 fpos;"
                    "layout(location = 0) out vec4 color;"
                    "void main(){"
                    "  color = vec4( texture(tex1, fuv).rgb, 1.0);" 
                    "}";